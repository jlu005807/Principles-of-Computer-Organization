# 1.说明计算机系统的层次结构。

- **P7**

- 常见的五级计算机系统的层次结构
- 其中软硬件交接界面为操作系统机器和机器语言机器之间
  - 硬件：传统机器M1，微程序机器M0
  - 软件：操作系统级及以上各级虚拟机

- 翻译器（编译器）将高级语言程序**翻译**为机器语言程序，而机器语言由操作系统和微程序**解释**后由硬件执行

![image-20240917201537712](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917201537712.png)

![img](D:\Internt of Thing\e_book\计算机组成原理\note\assets\2288178-20211210000028631-1061521216.png)



# 2.说明冯诺依曼体系结构的特点。

- **P8**

- 五大部件：运算器，存储器，控制器，输入设备和输出设备
- 指令和数据用**二进制**表示，并以同等地位存放于存储器，按地址寻访
- 指令由**操作码**和**地址吗**组成，**顺序存放**所以通常顺序执行
  - 操作码：操作性质
  - 地址码：位置

- 运算器为中心，但现代计算机以存储器为中心

- 冯·诺依曼机的基本工作方式是：控制流驱动方式


![image-20240917203954322](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917203954322.png)

![image-20240917204702152](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917204702152.png)





# 3.什么是机器字长、指令字长、存储字长?

- **P17**
- 机器字长为CPU一次能处理**数据的位数**，与寄存器位数有关
- 指令字长为计算机**指令所占用的位数**，指令字长取决于从操作码的长度、操作码地址的长度和操作码地址的个数。
  - 指令流通常是（主存流向控制器）
- 存储字长通常指一个存储单元存储二进制代码的位数，**MDR（Memory Data Registe)** 的位数，指数据寄存器中的位数，

![image-20240917205527047](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917205527047.png)







# 4.系统总线包括哪三类？起到什么作用？

- **P43**
- 总线是连接多个部件的**信息传输线**，是各部件共享的**传输介质**
- 系统总线为总线的一种，根据传输信息的不同分为三种
  - **数据总线**：传输各功能部件之间的数据信息，双向传输，位数与机器字长，存储字长有关，同时位数成为宽度
  - **地址总线**：数据地址或设备地址，指明CPU访问的地址，由CPU输出，单向传输，位数与存储单元个数有关
  - **控制总线**：控制信号，单向或者双向，对于CPU有输入和输出

![image-20240917210403098](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917210403098.png)





# 5.总线判优控制是解决什么问题的？总的来说可以分为哪两种方式？

- **P57**
- 若多个主设备同时要使用总线时，由总线判优控制按一定优先级顺序确定哪个主设备能使用总线
- 总线判优控制解决多个部件同时申请总线时的总线使用权分配问题
- **集中式**和**分布式**

![image-20240917211422643](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917211422643.png)







# 6.集中式总线控制优先权仲裁方式有哪三种？各有什么特点？

- **P57**

- **链式查询方式**

  - 线路结构简单，容易扩充设备
  - 对电路故障敏感，优先级固定，优先级别低的设备难获得请求

  ![image-20240917211648377](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917211648377.png)



![image-20240917211759468](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917211759468.png)

- **计数器定时查询**
  - 优先级设置灵活，对电路故障不那么敏感
  - 增加了控制线，n个设备大约需要⌈ log_2⁡n ⌉+2条控制线，控制较复杂

  ![image-20240917212406940](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917212406940.png)

![image-20240917212440315](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917212440315.png)





- **独立请求方式**
  - 响应速度快，优先次序控制灵活
  - 控制线多，设备 n 个，则需要 2n+1 条控制线，其中的 1 是指反馈线，控制逻辑复杂

![image-20240917212713390](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917212713390.png)

![image-20240917212737748](C:\Users\12894\AppData\Roaming\Typora\typora-user-images\image-20240917212737748.png)









# 7.简述总线周期的4个阶段。

- **P59**

- 总线周期：**完成一次总线操作的时间**

- **申请分配**：主模板申请，经总线仲裁机构决定下一传输周期的总线使用权授予某一申请者。

- **寻址**：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。

- **传数**：主模块和从模块进行数据交换，数据由源模块发出，经数据总线流入目的模块。

- **结束**：撤除主模板信息，让出总线使用权

  ![image-20240917213410169](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917213410169.png)







# 8.总线通信控制是解决什么问题的？总的来说有哪几种控制方式？各自的特点是什么？

- **P59**

- 主要解决通信双方如何获知传输开始和结束，如何协调如何配合

- **总线传输周期**：连接在总线上的两个部件完成一次完整且可靠的信息传输时间

- **同步通信**：

  - 统一时标（通常由CPU的总线控制部件发出）

  - 规定明确统一，模块间的配合简单一致

  - 强制性同步，影响效率，设计局限性，不灵活

  - 用于总线长度短，各部件存取时间比较一致

  - 数据传输率与传输周期和数据位数有关

    ![image-20240917214302692](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917214302692.png)

![image-20240917214327954](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917214327954.png)

![image-20240917214352105](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917214352105.png)

* **异步通信**：

  * 允许各模板速度不一致，采用应答方式（握手方式）

  * 分为**不互锁**，**半互锁**，**全互锁**

    ![image-20240917214749051](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917214749051.png)

- **半同步通信**：

  - 地址，命令，数据信号发出时间参照系统时钟某个前沿，接收方采用系统时钟后沿时刻判断识别

  - 允许不同速度各模板工作，并通过（WAIT)响应信号线或采用插入时钟（等待）周期协调

  - 用于系统工作速度不高但又包含速度差异较大的各类设备组成的简单系统

  - 控制比异步简单，可靠性较高，同步结构较简单

  - 系统时钟频率低，速度较慢

    ![image-20240917220003446](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917220003446.png)

- **分离式通信**：
  - 各模板需要申请
  - 限定时间传送信息，采用同步方式，不等待回答
  - 准备数据不占用总线
  - 控制复杂

![image-20240917220554490](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240917220554490.png)









# 9.串行传输和并行传输有何区别？各适用于什么场合？

- *P??*
- **串行传输**：
  - 一条数据线，一位一位依次传输，数据的各个比特（bit）是按照时间序列逐个发送和接收的
  - 传输效率低
  - 适用于长距离，减少衰减
  - 通常用于计算机与外部设备（如打印机、鼠标、键盘）的通信，以及远距离通信（如网络连接、无线通信）。

* **并行传输**：
  - 数据线多条，成组传输
  - 传输效率高
  - 适用于短距离通信，因为随着线路长度的增加，信号同步和干扰问题会变得更严重。
  - 并行传输适用于需要快速传输大量数据的场合，如内存模块、主板内部的总线、打印机的打印头与控制电路之间的数据传输。













# 10.试比较RAM和ROM。

* **P69**
* **RAM（随机存取存储器）**:
  - 随机访存，存储时间与物理位置无关，可读可写
  - 主存采用，主要用于存储临时数据和程序，是CPU执行程序时的工作空间。它允许快速访问和频繁的数据更新。
  - 速度快于ROM,但成本较高且有易失性

- **ROM（只读存储器）**：
  - 存储固件或系统软件，一般不允许用户修改
  - 用于存储不需要频繁更改的系统级软件，如BIOS或固件，这些软件在系统启动时加载到RAM中。
  - 速度较慢，但成本相对较低

![image-20240918105939112](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918105939112.png)







# 11.从实现技术的角度，试比较SRAM和DRAM。

- **P76**
- **静态 RAM (Static RAM, SRAM)**：
  - 用触发器工作原理存储信息，断电易失去信息，但不需要刷新
  - 由 MOS 管组成基本单元电路
  - 速度快，但成本较高

- **动态 RAM (Dynamic RAM, DRAM)**：
  - 电容存储电荷的原理寄存信息，需要刷新
  - 基本单元电路有三管式和单管式两种
  - 集成度高，相同价格容量大于SRAM，但是速度较慢，且功耗较高

![image-20240918111422428](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918111422428-1726629264641-2.png)



# 12.存储芯片内的地址译码方式有几种？各自特点及应用场合？

- **P75**
- **线选法**：
  - 一根字选择线直接选中一个存储单元的各位（如一个字节）
  - 结构简单，用于容量不大的存储芯片
  - 当容量变大时，需要的地址线指数级增多

- **重合法**：
  - 又称为二维地址译码
  - 通常由行地址译码器（X译码器）和列地址译码器（Y译码器）组成
  - 行和列的交汇处共同锁定一个单元，适用于大容量存储芯片
  - 重合法可以提高存储器的集成度和存储密度
  - 结构较复杂

![image-20240918220650584](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918220650584-1726668411993-1-1726668415931-3.png)





# 13.什么是动态RAM的刷新？刷新有几种方式？简要说明之。

- **P85**
- 刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程
- 通常有三种方式刷新：集中刷新、分散刷新和异步刷新。
- **集中刷新**：
  - 规定刷新周期，集中刷新全部存储单元
  - 存在“死区”，无法进行读写操作

![image-20240918220959452](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918220959452-1726668603033-5.png)

- **分散刷新**：
  - 指对每行存储单元的刷新分散到每个存取周期内完成
  - 不存在停止读写操作的死时间，但存取周期长，系统速度降低

![image-20240918221117838](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918221117838-1726668679571-7.png)

![image-20240918221148731](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918221148731-1726668710273-9.png)



- **异步刷新**：
  - 结合上述两种方法
  - 缩短了‘死区’时间，又充分利用最大刷新间隔为2ms



![image-20240918221523498](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918221523498-1726668924562-11.png)

![image-20240918221539720](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918221539720.png)

- **如果将动态 RAM 的刷新安排在 CPU 对指令的译码阶段，由于这个阶段 CPU 不访问存储器，所以这种方案既克服了分散刷新需独占 0.5 µs 用于刷新，使存取周期加长且降低系统速度 的缺点，又不会出现集中刷新的访存“死区”问题，从根本上提高了整机的工作效率。**











# 14.存储容量扩展有哪几种方法？

- **P91**
- 通常有位扩展和字扩展，字位扩展
- **位扩展**：
  - 增加存储字长

![image-20240918221747658](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918221747658-1726669068778-13.png)

![image-20240918221812847](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918221812847.png)

- **字扩展**：
  - 增加存储器字的数量

![image-20240918221936146](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918221936146-1726669177381-15.png)

![image-20240918221951649](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918221951649.png)

![image-20240918222015974](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918222015974-1726669217081-17.png)

- **字、位扩展**：
  - 指既增加存储字的数量，又增加存储字长

![image-20240918222106764](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918222106764-1726669268085-19.png)

![image-20240918222120492](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918222120492.png)

![image-20240918222131802](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240918222131802-1726669292848-21.png)

















































# 15.使用汉明码进行校验时，需要增加k位检测位，且k位的检测位和n位的待检测二进制代码位之间要满足什么关系？为什么？

- **P100**
- **2^k ≥ n+k+1**

![image-20240926124946223](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926124946223-1727326189579-1.png)







# 16.已知收到的海明码为0100111（按配偶原则配置），试问欲传送的信息是什么？

- P1 = 1⊕3⊕5⊕7 = 0 
- P2 = 2⊕3⊕6⊕7 = 1 
- P4 = 4⊕5⊕6⊕7 = 1 
- P4P2P1 = 110
- (110)2=6->第六位出错，纠正为 0100101，故要求传送的信息为 0101



# 17.什么是多体并行存储器？有哪两种存储体编址方式，各自有什么特点？

- **P104**

- 多体模块组成的**存储器**

- 每个模块有相同**容量**和**存取速度**

- 各模块有独立的的**地址寄存器 (MAR)** 、**数据寄存器 (MDR)** 、**地址译码**、**驱动电路和读／写电路**

- 并行工作，交叉工作

- 两种存储体编址方式：**高位交叉编址**和**地位交叉编址**

  ![image-20240926130354012](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926130354012-1727327035786-9.png)

- 高位交叉：

  - 高位地址表示**体位**，低位地址为**体内地址**
  - **顺序存储**

![image-20240926125940132](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926125940132-1727326781667-3.png)

- 低位交叉：
  - 低位地址表示**体位**，高位地址为**体内地址**
  - **模M编址**

![image-20240926130059939](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926130059939-1727326861082-5.png)

![image-20240926130114985](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926130114985-1727326876254-7.png)

- 例题：

  ![image-20240926130623094](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926130623094-1727327184401-11.png)

  ![image-20240926130636491](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926130636491-1727327197462-13.png)



















# 18.Cache、主存和辅存构成的三级存储系统分别的目的是什么？设计依据是？

- **P109**
- **Cache-主存层次**：
  - 解决 CPU 和主存**速度不匹配**的问题
  - 程序访问的局部性原理
  - 缓存的速度比主存的速度高

![image-20240926131617489](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926131617489-1727327779191-15.png)

![image-20240926131629228](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926131629228-1727327790401-17.png)

- 主存-辅存层次：
  - 解决存储系统的容量问题
  - 辅存的速度比主存的速度低，而且不能和 CPU 直接交换信息，但它的容量比主存大得多，可以存放大量暂时未使用得信息。
  - 当 CPU 需要用到这些信息时，再将辅存的内容调入主存，供 CPU 直接访问。
  - 主存和辅存之间的数据调用是由硬件和操作系统共同完成的。



























# 19.请简述Cache的基本工作原理。

- **P110**

- 任何时刻都有一些主存块处在缓存块中

- 需要的字已经在缓存中，即可直接访问 Cache（**命中**）

- 需的字不在 Cache 内，此时需将该字所在的主存整个字块一次调入 Cache 中（**未命中**)

- 每个缓存块需设一个标记 ，表示当前存放的是哪一个主存块，该标记的内容相当于主存块的编号。

  ![image-20240926132015970](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926132015970.png)

- 关于命中率：
  - 命中率h=Nc/(Nc+Nm)
  - Nc 为访问 Cache 的总命中次数，Nm为访问主存的总次数

![image-20240926180530694](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926180530694-1727345134035-1.png)

- 例题：

![image-20240926180558561](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926180558561-1727345159532-3.png)

- 关于Cache容量：

![image-20240926180617921](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926180617921-1727345178849-5.png)

![image-20240926180631640](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926180631640-1727345192913-7.png)













# 20.试比较主存-Cache管理中三种地址映射的方法，并分别给出在三种地址映射下，主存地址划分。

- **P117**
- 由**主存地址映射到 Cache 地址**称为地址映射。
- **直接映射**（固定的映射 关系）、**全相联映射**（灵活性大的映射关系）、**组相联映射**（上述两种映射的折中）。

- **直接映射**：
  - 每个主存块只与一个缓存块相对应
  - 实现简单，利用主存地址某些位直接判断
  - 但不够灵活，如果重复访问对应同一缓存位置的不同主存块，就要不停替换，从而降低了命中率

![image-20240926181029424](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926181029424-1727345430345-9.png)

![image-20240926181046917](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926181046917-1727345448362-11.png)

- **全相联映射**：
  - 允许主存中每一字块映射到 Cache 中的**任何一块位置**上。
  - 方式灵活，命中率较高，并缩小了块冲突率
  - 逻辑电路多，成本高

![image-20240926181502687](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926181502687-1727345703898-13.png)

- **组相联映射**：
  - 直接映射和全相联映射的一种折中。把 Cache 分成 Q 组，每组 R 块
  - 组相联映射的性能及其复杂性介于直接映射和全相联映射两者之间

![image-20240926181636464](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926181636464-1727345797738-15.png)

- 例题：
- 直接映射

![image-20240926181828103](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926181828103-1727345909512-17.png)

- 各个映射

  ![image-20240926181902638](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926181902638-1727345943545-19.png)

![image-20240926181917563](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926181917563-1727345958683-21.png)













# 21.Cache-主存间的替换策略有哪些，请简述。

- **P122**
- 当新的主存块需要调入 Cache 并且它的可用空间位置又被占满时，需要替换掉 Cache 的数据，这就产生了替换策略（算法）问题
- 常用的替换算法有先进先出算法、近期最少使用算法和随机法。

- **先进先出 (First-In-First-Out, FIFO) 算法**
  - 选择最早调入的Cache的字块进行替换
  - 容易实现，开销小
  - 但没有根据访存的局部性原理，故不能提高 Cache 的命中率

![image-20240926182338176](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926182338176-1727346219372-23.png)

- **近期最少使用 (Least Recently Used, LRU) 算法**
  - 比较好地利用访存局部性原理，替换出近期用得最少的字块
  - 需要记录Cache中各字块使用情况
  - 比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间
  - LRU 算法的平均命中率比 FIFO 的高

![image-20240926182532166](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926182532166-1727346333230-25.png)

- **随机法**
  - 随机确定被替换的块
  - 采用一个随机数产生器

![image-20240926182632870](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926182632870-1727346394038-27.png)

































# 22.发生主存写请求时，如何保证Cache和主存的一致性？

- **P113**
- 对于写操作，对 Cache 块内写入的信息，必须与被映射的主存块内的信息完全一 致
- **写直达法 (Write-through) ，又称为存直达法（ Store-through)**
  - 写操作时数据既写入 Cache 又写入主存
  - 随时保证主存和 Cache 的数据始终一致，但增加了访存次数
  - 写操作时间就是访问主存的时间，读操作时不涉及对主存的写操作，更新策略比较容易实现

![image-20240926195929940](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926195929940.png)

- **写回法 (Write-back) ，又称为拷回法 (Copy-back)**
  - 写操作时只把数据写入 Cache 而不 写入主存，但当 **Cache 数据被替换出去时才写回主存**
  - 为了识别 Cache 中的数据是否与主存一致， Cache 中的每一块要增设一个标志位
  - 写操作时间就是访问 Cache 的时间，读操作 Cache 失效发生数据替换时，被替换的块需写回主存，增加了 Cache 的复杂性

![image-20240926200125950](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926200125950-1727352089407-1.png)

- 关于两者的对比

![image-20240926200159951](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926200159951-1727352121390-3.png)























# 23.影响Cache-主存层平均访问时间的因素有哪些？如果降低平均访存时间，可以怎么办？

- **P??**

- **缓存命中率**
- **缓存未命中的访问时间**
- **缓存结构**
- **缓存替换策略**
- **缓存块大小**
- **写策略**
- 降低平均访存时间：
  - **增加缓存容量**
  - **提高缓存的相联度**
  - **优化缓存替换策略**
  - **调整缓存块大小**
  - **使用预取技术**
  - **多级缓存设计**
  - **缓存行（Cacheline）对齐**
  - **合理利用写策略**

![image-20240926200755419](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240926200755419-1727352476566-5.png)



















































# 24.I/O地址码的编制方式有哪两种？

* **P159**
* 通常将 I/O设备码看作**地址码**
* 对 I/O地址码的编址可采用两种方式：**统一编码**和**不统一编码**
* 统一编码
  - 将I/O地址看作**存储器地址**的一部分
  - 对I/O设备的访问，所用指令与访存指令相似
  - 占用了存储空间，减少了主存容量，无需专用的I/O指令

- 不统一编码
  - I/O地址和存储器地址分开
  - 访问I/O有专用的指令
  - 不占用存储空间，不影响主存容量，需专用的I/O指令

![image-20240930213516337](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930213516337-1727703318976-1.png)

























# 25.I/O与主机交换信息有哪几种控制方式？各有何特点？

- **P161**
- I/O 设备与主机交换信息时，共有5种控制方式：**程序查询方式**、**程序中断方式**、**直接存储器存取方式 (DMA)** 、I/0 通道方式、 I/0 处理机方式。
- 程序查询方式
  - CPU不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息
  - 求 I/O 接口内设置一个能反映 I/O 设备**是否准备就绪的状态标记**
  - 主机和I/O串行工作
  - CPU反复查询过程中停止工作，效率低
  - CPU从设备取出数据时停止工作，CPU和I/O串行工作

![image-20240930213930589](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930213930589-1727703571844-3.png)

![image-20240930213945960](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930213945960-1727703587935-5.png)

- 工作示意图：

![image-20240930214201307](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930214201307-1727703722236-7.png)

- 程序中断查询：

  - CPU启动I/O设备后**不查询设备是否准备就绪**，继续执行自身程序

  - I/O准备就绪后发送**中断请求**

  - CPU响应I/O请求后，中断现行程序，转至**中断服务程序**，占用了CPU内部的一些寄存器

  - 处理完信息交换，回到原程序断点处，继续执行

  - CPU向I/O 设备发读指令后，仍在处理其他事情（如继续在算题），消除了“踏步”行为

  - CPU 执行程序与 I/0 设备做准备是同时进行的，充分利用了CPU资源

  - 对于程序中断方式，硬件需要增加相应电路，软件方面需要编制中断服务程序

    ![image-20240930214930526](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930214930526-1727704171945-9.png)

![image-20240930214945902](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930214945902-1727704186896-11.png)

- 工作示意图：

  ![image-20240930215024868](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930215024868-1727704225893-13.png)

- DMA方式：
  - I/O设备与主存直接交换信息，而不占用CPU
  - 主存与 I/O 设备之间有一条**数据通路**
  - 若出现 DMA CPU 同时访问主存， CPU 总是将总线占有权让给 DMA, 通常把 DMA 的这种占有称为**窃取或挪用**，一般为一个存取周期，又称为窃取周期或挪用周期
  - 在 DMA 窃取存取周期时， CPU 尚能继续做内部操作（如乘法运算），只是让出总线使用权
  - 采用 DMA 方式时，也需要增加必要的 DMA 接口电路

 ![image-20240930215729272](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930215729272.png) <img src="D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930215618295-1727704579361-15.png" alt="image-20240930215618295" style="zoom:80%;" />

- 工作示意图：

  ![image-20240930215750288](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20240930215750288-1727704671106-18.png)























# 26.I/O接口有什么作用。

- **P185**
- 接口可以看作两个系统或两个部件之间的交接部分，它既可以是两种硬设备之间的连接电路，也可以是两个软件之间的共同逻辑边界
- I/O接口通常是指主机与 I/O 设备之间设置的一个**硬件电路及其相应的软件控制**。
- 不同的 I/O 设备都有其相应的设备控制器，而它们往往都是**通过 I/O 接口与主机取得联系的**。
- 一台机器通常配有多台 I/O 设备，它们各自有其设备号（地址），通过接口可实现**I/O设备的选择**。
- I/O 设备种类繁多，速度不一，与 CPU 速度相差可能很大，通过接口可实现**数据缓冲，达到速度匹配**。
- 有些 I/O 设备可能串行传送数据，而 CPU 一般为并行传送，通过接口可实现**数据串－并格式的转换**
- I/O 设备的输入输出电平可能与 CPU 的输入输出电平不同，通过接口可实现**电平转换**。
- CPU 启动 I/O 设备工作，要向 I/O 设备发各种控制信号，通过接口可**传送控制命令**。
- I/O 设备需将其工作状态（如“忙＂”就绪”“错误”“中断请求”等）及时向 CPU 报告，通过接口可**监视设备的工作状态，并可保存状态信息，供 CPU 查询**。
- **注意**，接口和端口是两个不同的概念
- 端口是指接口电路中的一 些寄存器，这些寄存器分别用来存放数据信息、控制信息和状态信息，相应的端口分别称为数据端口、控制端口和状态端口。若干个端口加上相应的控制逻辑才能组成接口。
- 接口的分类：**P188**
  - 按数据传送方式分类，有**并行接口**（一个字节或一个字的所有位同时传送和**串行接口**（一位一位传送）两类。
  - 按功能选择的灵活性分类，有**可编程接口**和**不可编程接口**两种
  - 按通用性分类有**通用接口和专用接口**
  - 按数据传送的控制方式分类，有**程序型接口和 DMA 型接口**

![image-20241009110656347](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241009110656347-1728443219747-1.png)

![image-20241009110715260](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241009110715260-1728443236392-3.png)

![image-20241009214527666](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241009214527666-1728481531771-1.png)

![image-20241009214540054](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241009214540054-1728481542015-3.png)



























# 27.程序查询方式和程序中断方式都由程序实现外围设备的输入输出，它们有何不同？

* **P189**

* 程序查询方式的核心问题在于每时每刻需**不断查询 I/O设备是否准备就绪**。

* 程序查询方式是用户在**程序中安排一段输入输出程序**，它由 I/O 指令、测试指令和转移指令等组成。CPU 一旦启动 I/O 后，就进入这段程序，时刻查询 I/O 准备的情况，若未准备就绪就**踏步等待**；若准备就绪就实现传送。在输入输出的全部过程中，CPU 停止自身的操作。

* 计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行， 转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序，这就是“中断＂

* 程序中断方式虽也要用程序实现外部设备的输入、输出，但它只是**以中断服务程序的形式插入到用户现行程序中**。即 CPU 启动 I/O 后，继续自身的工作，不必查询 I/O 的状态。而 I/O 被启动后，便进入自身的准备阶段，当其准备就绪时，向 CPU 提出中断请求，此时若满足条件，CPU 暂停现行程序，转入该设备的中断服务程序，在服务程序中实现数据的传送。

  































# 28.以I/O设备的中断处理过程为例，说明一次程序中断的全过程。

- **P198**
- 由CPU发启动 I/O 设备指令，将**接口中的 B 置“1”，D 置“0”**
- 接口启动输入设备开始工作
- 输入设备将数据送入数据缓冲寄存器
- 输入设备向接口**发出“设备工作结束”信号，将 D 置为“1”，B 置为“0”**，标志设备准备就绪
- 当设备准备就绪(D=1)，且本设备未被屏蔽(MASK=O)时，在指令执行阶段的结束时刻，由 CPU **发出中断查询信号**
- 设备中断请求触发器 INTR 被置为“1”'，标志设备向 CPU 提出中断请求。与此同时，INTR 送至排队器，进行**中断判优**
- 若 CPU 允许中断(EINT=1)，设备又被排队选中，即进入中断相应阶段，由**中断响应**信号 INTA 将排队器输出送至编码器形成向量地址
- 向量地址送至 PC，作为下一条指令的地址
- 由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后即无条件转至该设备的服务程序入口地址，开始执行**中断服务**程序，进入中断服务阶段，通过输入指令将数据缓冲寄存器的输入数据送至 CPU 的通用寄存器，再存入主存相关单元
- 中断服务程序的最后一条指令是中断返回指令，当其执行结束后，即**中断返回**至原程序的断点处。至此，一个完整的程序中断处理过程即告结束
- 综上所述，可将一次中断处理过程简单地归纳为中断请求、中断判优、中断响应、中断服务和 中断返回 5个阶段。
  - 其中中断服务程序分为四大部分：保护现场、中断服务、恢复现场、中断返回


![image-20241009215505917](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241009215505917-1728482107088-5.png)

![image-20241009215520848](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241009215520848-1728482122096-7.png)

![image-20241013100839306](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013100839306-1728785322247-1.png)

































# 29.在DMA方式中有没有中断请求，为什么？DMA接口电路中应设置哪些硬件。

- **P200**
- **DMA有中断请求**，只是数据不通过CPU。DMA控制器在传送完所有字节时，通过中断请求线发出中断信号。CPU在接收到中断信号后，转入中断处理程序进行后续处理。
- 必须注意，这里的中断与 5.5 节介绍的 I/O 程序中断方式的技术相同，但中断的目的不同，前面是为了数据的输入或输出，而这里是为了报告一批数据传送结束。它们是 I/O 系统中不同的中断事件。

![image-20241013101737405](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013101737405-1728785858508-3.png)

- 硬件：**P204**

- 补充DMA接口功能：

  - 申请传送
  - 处理总线控制权转交
  - 管理总线
  - 修正数据地址和地址长度
  - 给出操作完成信号

  ![image-20241013103733884](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013103733884-1728787054961-5.png)

- **主存地址寄存器 (AR)**:

  - AR用于存放主存中需要交换**数据的地址**。
  - 传送数据前，将数据在主存中的首地址送到AR
  - 传送过程中，每交换一次数据，AR内地址加一，知道一批数据传送完

- **字计数器 (WC)**：
  - WC用于记录传送数据的**总字数**，通常以交换字数的补码值预置
  - 传送过程中，每传送一个字，WC加一，直到WC为0（最高位产生进位），表示传送完毕
  - 最后DMA发送中断请求信号

- **数据缓冲寄存器 (BR)**
  - BR 用于**暂存每次传送的数据**

-  **DMA 控制逻辑**
  - DMA 控制逻辑**负责管理 DMA 的传送过程**，由控制电路、时序电路及命令状态控制寄存器等组成。
  - 设备准备好数据字，向DMA接口提出申请（DREQ），DMA 控制逻辑向CPU发出总线使用权的请求信号 (HRQ)
  - DMA 控制逻辑收到CPU响应信号HLDA,DMA 控制逻辑负责管理DMA传送全过程

- **中断机构**
  - 当字计数器溢出（全 “0”) 时，表示一批数据交换完毕，由＂溢出信号“通过中断机构向 CPU **提出中断请求**，请求 CPU进行DMA 操作的后处理。

- **设备地址寄存器 (DAR)**
  - DAR 存放 I/O 设备的**设备码**或表示设备信息存储区的**寻址信息**

![image-20241013103755173](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013103755173-1728787076195-7.png)

![image-20241013103807290](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013103807290-1728787088744-9.png)

![image-20241013103821389](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013103821389-1728787102451-11.png)

































# 30.DMA方式中的中断请求和程序中断中的中断请求有何区别？

- P**208**
- 从数据传送看，程序中断方式靠**程序**传送，DMA 方式靠**硬件**传送
- 从 CPU 响应时间看，程序中断方式是在一条**指令执行结束时**响应，而 DMA 方式可在指令周期内的**任一存取周期结束时**响应。
- 程序中断方式有处理异常事件的能力，而 DMA 方式没有这种能力，主要用于大批数据的传送，
- 程序中断方式需要中断现行程序，故需保护现场；DMA 方式不中断现行程序，无须保护现场
- DMA 的优先级比程序中断的优先级高

![image-20241013104111368](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013104111368-1728787272477-13.png)

























































# 31.DMA和主存交换数据时有哪三种方法？分别简述。

- **P201**

- DMA 方式中，由于 DMA 接口与 CPU 共享主存，这就有可能出现两者争用主存的冲突。 为了有效地分时使用主存，通常 DMA 与主存交换数据时采用如下三种方法：**停止CPU访问主存、周期挪用（周期窃取）、交替访问**

- 停止CPU访问主存方式

  - 传送数据时，DMA向CPU发一个停止信号，要求CPU放弃总线控制
  - 控制简单，，适用千数据传输率很高的 I/O设备实现成组数据的传送
  - 缺点是 DMA 接口在访问主存时， CPU 基本上处于不工作状态或保持原状态。

  ![image-20241013105509574](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013105509574-1728788110642-15.png)

- 周期挪用（周期窃取）方式

  - DMA请求时，I/O设备挪用或窃取总线占用权一个或几个主存周期，无请求CPU继续访存
  - 与CPU 暂停访存的方式相比，这种方式既实现了 I/O 传送，又较好地发挥了主存与 CPU 效率，是一种广泛采用的方法。
  - 应该指出， I/O设备每挪用一个主存周期都要申请总线控制权、建立总线控制权和归还总线控制权。

  ![image-20241013105607594](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013105607594.png)

  ![image-20241013105630833](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013105630833-1728788192193-19.png)

- DMA 与CPU 交替访问方式

  - 这种方法适合千 CPU 的工作周期比主存存取周期长的情况。
  - 那么可将一个 CPU 周期分为 C1和C2两个分周期，其中 C1专供 DMA 访存，C2专供 CPU 访存
  - 不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和 c2 分别控制的
  -  CPU 既不停止主程序的运行也不进入等待状态，就完成了 DMA 的数据传送。但相应的硬件逻辑变得更为复杂。

  ![image-20241013105651815](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013105651815-1728788212973-21.png)

  







































# 32.简述DMA的工作过程。

- **P205**
- DMA 的数据传送过程分为**预处理、数据传送和后处理** 3个阶段
- 预处理：CPU预置信息，由 CPU 执行几条输入输出指令完成，即程序的初始化阶段。之后CPU继续执行原来程序。
  - 给DMA控制逻辑指明**数据传送方向**是输入（写主存）还是输出（读主存）
  - 向DAR输入**设备号**，启动设备
  - 向AR送入交换**数据的主存起始地址**
  - 对WC赋予**数据个数**

![image-20241013124310322](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013124310322-1728794591614-23.png)

- 预处理完后，待 I/O 设备得到主存总线的控制权后，数据的传送便由该 DMA 接口进行管理。
- 数据传送
  - DMA 方式是以**数据块**为单位传送的

![image-20241013124648766](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013124648766-1728794809841-25.png)

![image-20241013124717181](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013124717181-1728794838448-27.png)

![image-20241013124741302](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013124741302-1728794862510-29.png)

- 数据传送后，进入后处理
- 后处理
  - DMA的中断请求得到响应，CPU停止原程序转去中断服务程序
  - 校验数据，决定是否继续传送，测试错误

![image-20241013125048499](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013125048499-1728795049460-31.png)

- 总流程图：

![image-20241013125135669](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013125135669-1728795097342-33.png)































# 33.DMA接口的类型有哪几种？

- **P209**
- 现代集成电路制造技术已将 DMA 接口制成芯片，通常有**选择型和多路型**两类
- 选择型 DMA 接口
  - 在物理上可连接多个设备，在逻辑上只允许连接一个设备
  - 某一段时间内，DMA接口只为一个设备服务，关键是预处理时DAR的设备号
  - 适用于数据传输率很高的设备

![image-20241013125555538](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013125555538-1728795356557-35.png)

- 多路型 DMA 接口
  - 不仅在物理上可以连接多个设备，而且在逻辑上也允许多个设备同时工作
  - 设备采用字节交叉传送数据
  - 每个设备有一套寄存器，存放设备参数
  - 又分为**链式多路型 DMA 接口和独立请求多路型 DMA 接口**

![image-20241013125924892](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013125924892-1728795565990-37.png)



![image-20241013125939642](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241013125939642-1728795581103-39.png)









































# 34A.说明补码加/减法运算步骤。（*）

- **P237**
- 加减法运算是计算机中最基本的运算
- 因减法运算可看作被减数加上一个减数的负值，即 A -B=A +(-B)
- 采用**补码**作加减法运算
- 补码表示的两个数在进行加法运算时，可以把**符号位与数值位同等处理**
- 对于加法：
  - 整数  [A]补 +［B]补＝[ A+B]补 (mod 2^n+1)
  - 小数  [A]补 +［B]补＝[ A+B]补 (mod 2^n)
- 对于减法：
  - 整数  [A-B]补 =[A]补 +［-B]补 (mod 2^n+1)
  - 小数  [A-B]补 =[A]补 +［-B]补 (mod 2^n)

- 将符号位产生的进位自然丢掉即可。

  ![image-20241014211458619](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241014211458619-1728911701483-1.png)

- 溢出判断有两种方法：**用一位符号位判断溢出**、**用两位符号位判断溢出**

- 用一位符号位判断溢出：

  - 对于加法，符号不同的两个数相加不会溢出
  - 对于减法，符号相同的两个数相加不会溢出
  - 只要实际两个操作数（减法时即为被减数和“求补”以后的减数）符号相同，结果又与原操作数的符号不同，即为溢出。
  - 计算机中，通常用**符号位产生的进位**与**最高有效位产生的进位(即现符号位）异或**操作后，按其结果进行判断。若异或结果为1 ，即为溢出；异或结果为0 ，则无溢出。

![image-20241014212024522](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241014212024522-1728912025673-3.png)

![image-20241014212038927](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241014212038927.png)

- 用两位符号位判断溢出：

  - 对于变形补码首次出现：**P223**

    ![image-20241014212250728](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241014212250728-1728912171624-5.png)

  - 两位符号位连同数值一起运算，并且高位进位自动丢失
  - 当2位符号位不同时，表示溢出，否则；无溢出
  - 溢出时，符号位"01” 表示正溢出,"10"则表示负溢出
  - 高位（第 1位）符号位永远代表真正的符号
  - 在计算机中，寄存器和主存中只需1位符号位，双符号在加法器中必要，相加时，寄存器中一位符号的值要同时送到加法器的两位符号位的输入端。

![image-20241014212857125](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241014212857125-1728912538746-9.png)

- **流程**：
  - 将两个操作数的补码送入寄存器A和X，
  - 判断是否是加法，是直接（A）+（X）->A,不是下一步
  - 对（-X)求补码，(A)+(-X)->A
  - 最后判断溢出

![image-20241014213856043](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241014213856043-1728913137235-11.png)







# 34B.说明浮点加/减法运算的基本步骤。

- **P269**

- 补充浮点数：

  - **P229**

  - 浮点数表示：N=S*r^j

  - S为尾数（可正可负）， j为阶码（可正可负）， r是基数（或基值）

  - 在计算机中规定浮点数的**尾数用纯小数形式**

  - 此外，**尾数最高位为1**为规格化数

    ![image-20241015223601476](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015223601476.png)

  - 浮点数由阶码和尾数组成，阶码是整数

  - **阶符和阶码的位数**合起来反映浮点数的表示范围及小数点的实际位置；

  - 尾数是小数，其位数反映了浮点数的精度；尾数的符号 Sf 代表浮点数的正负。

    ![image-20241015223933675](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015223933675-1729003176731-1.png)

    ![image-20241015223959938](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015223959938-1729003201330-3.png)

  - 浮点数表示范围：

    ![image-20241015224152768](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015224152768-1729003313794-5.png)

- 由于浮点数小数点固定，所以尾数加减同定点数
- 由于阶码反映小数点实际位置，必须阶码相同才可以运算尾数

1. **对阶**，使两数的小数点位置对齐

   - 使两操作数的小数点位置对齐，即使两数的阶码相同

   - 求阶差，**小阶向大阶看齐**，阶数小的尾数右移n位，阶码加n,**尾数右移时可能会发生数码丢失，影响精度。**

     ![image-20241015224954099](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015224954099-1729003795159-7.png)

2. **尾数求和**，将对阶后的两尾数按定点加减运算规则求和（差）。

   - 同34A,利用补码运算

     ![image-20241015225106743](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015225106743-1729003867569-12.png)

3. **规格化**，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。

   - 当基数为2，尾数S规格化为 1/2<=|S|<1

   - 双符号位补码时，当尾数最高数值位和符号位不同即规格化

     ![image-20241015225427755](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015225427755-1729004068667-14.png)

     ![image-20241015225439998](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015225439998-1729004081156-16-1729004114571-18.png)

   - **左规**：当尾数出现00.0……或者11/1……时左规，尾数左移一位，阶码减一

     ![image-20241015225718838](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015225718838-1729004239822-20.png)

   - **右规**：当尾数出现01.XXXX或者10.XXXX时，尾数溢出，定点运算中不允许，但浮点数可以右规，尾数右移一位，阶码加一

     ![image-20241015225952407](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015225952407-1729004393409-22.png)

4. **舍入**：对阶合并右规时，尾数低位丢失可能有误差影响精度。舍入提高尾数精度

   - "0 舍 1 入“法：类似于四舍五入，尾数右移时，被移去的最高数值位（即当前被移去位）为 0，则舍去；被移去的最高数值位为1 ，则在尾数的末位加 1。如果溢出，右规

   - “恒置1”法：尾数右移时，不论丢掉的最高数值位是 “1” 或“0" ，都使右移后的尾数末位恒置 ”1” 。

     ![image-20241015230940755](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015230940755-1729004982228-24-1729004984485-26.png)

5. **溢出判断**：尾数右规后根据阶码判断。溢出由阶码的符号决定：阶码 01,xx 为上溢。 阶码 10, xx 为下溢，按机器零处理。

   ![image-20241015231706931](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241015231706931-1729005428027-28.png)

   











































































# 35A.说明原码乘/除法运算的基本步骤。（*）



- **P243原码乘法运算**
- 笔算乘法的改进，两数相乘可以视为**加法和移位**。A*B,则A为被乘数，B为乘数
- 运算过程：
  - 假设有n位乘数，则进行**n次加法运算和n次移位运算**
  - 由**乘数末位**确定被乘数是否与部分积相加，1加，0不加。然后**相加结果**右移一位形成新部分积。同时**乘数右移**一位形成新末位，最高位放部分积的最低位
  - 加法时，被乘数与原部分积高位相加，低位移至乘数空出最高位

- 用一个寄存器存放被乘数，一个寄存器存放乘积的高位， 另一个寄存器存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。

  ![image-20241019222714780](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019222714780-1729348038237-1.png)

  ![image-20241019222745185](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019222745185-1729348066241-3.png)

  ![image-20241019222814311](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019222814311-1729348095378-5.png)

- 原码一位乘法：

  - 乘积符号位由两原码符号位异或决定

    ![image-20241019222840370](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019222840370-1729348121540-7.png)

  - 接着两原码利用上述规则运算

    ![image-20241019222855404](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019222855404-1729348136446-9.png)



* 例子：

  ![image-20241019222923453](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019222923453-1729348164362-11.png)

![image-20241019222947044](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019222947044-1729348187934-13.png)

* 硬件配置：三个n+1位寄存器分别存放被乘数，乘数，部分积；移位和加控制电路受乘数末位控制；计数器C控制逐位相乘次数；S存放乘积符号，CM位乘法标记

  ![image-20241019223319133](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019223319133.png)

  ![image-20241019223339800](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019223339800-1729348420750-15-1729348431966-17.png)

- 控制流程：

  - 预处理(运算前)：清空A作为初始部分积，被乘数和乘数送入X和Q,计数器C存放乘数位数

  - 首先通过被乘数和乘数的符号位异或确定乘积的符号位存于S,将被乘数和乘数变为绝对值

  - 根据Qn的状态决定部分积是否加上被乘数，再右移一位重复n次

    ![image-20241019223903832](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019223903832-1729348744868-19.png)

- 原码两位乘法（了解）
- 用两位乘数(ab)的状态决定新部分积：
  - ab=00,原部分积右移两位
  - ab=01,原部分积加被乘数后右移两位
  - ab=10,原部分积加2倍被乘数后右移两位
  - ab=11,原部分积加3倍被乘数后右移两位

![image-20241019224441942](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019224441942-1729349083181-21.png)

![image-20241019224458917](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019224458917-1729349099959-23.png)

- **除法运算**

- 分析笔算除法：

  - 须通过比较被除数（或余数）和除数绝对值的大小来确定商值，即lxl - lyl ，若差为正（够减）上商1 ，差为负（不够减）上商0。
  - 每次减法总是保持余数不动低位补 ，再减去右移后的除数这一规则，则要求加法器 的位数必须为除数的两倍。所以**右移除数可以用左移余数代替**

  - 对于计算机，每一位商直接写到寄存器的最低位，并把原来的部分商左移一位

![image-20241019225214985](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019225214985-1729349536034-25.png)

![image-20241019225230094](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019225230094-1729349554012-27.png)

- 原码除法：

- 符号位单独处理：商符由两数符号位异或求得，而商值由两数绝对值相除得

- 小数定点除法对被除数和除数有一定的约束，即必须满足下列条件：

  -  0<|被除数|<=|除数|
  - 避免除数或者被除数为0，前者得无限大，后者得0
  - 商的位数一般和操作数相同

- 原码除法中由千对余数的处理不同，又可分为恢复余数法和不恢复余数法（加减交替法）两种

- 恢复余数法：

  - 当余数为负时，需加上除数，将其恢复成原来的余数。
  - 注意：**第一次上的商在商的整数位上，这对小数除法而言，可用它作溢出判断。**即当该位为 “1” 时，表示此除法溢出，不能进行，应由程序进行处 理；当该位为 “0” 时，说明除法合法，可以进行
  - 恢复余数延长机器除法时间，并且操作不规范
  - 例子：

  ![image-20241019225748695](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019225748695-1729349869519-29.png)

  ![image-20241019225833877](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019225833877-1729349935681-33.png)

* 加减交替法（不恢复余数法）

  ![image-20241019230352290](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019230352290-1729350233683-35.png)

  * 余数Ri大于零，商上“1”，2*Ri -|y|

  * 余数Ri小于零，商上“0”，2*Ri+|y|

    ![image-20241019230411064](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019230411064-1729350252193-37.png)

  * 例子：

    ![image-20241019230434024](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019230434024-1729350275430-39.png)

    ![image-20241019230453822](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019230453822-1729350295258-41.png)

- 硬件配置：三个n+1位的寄存器分别存放被除数，除数，余数；移位和加控制逻辑受 Q的末位见控制 (Qn = 1做减法， Qn = 0做加法）;计数器C控制逐位相除次数；CD为除法标记（区别与惩罚标记CM)；Y为溢出标记；S为商符

  ![image-20241019231132105](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019231132105-1729350692969-43.png)

- 控制流程：

  - 预处理即除法前：清空Q,被除数和除数输入A和X；计数器C存放被除数的位数；

  - 开始后，异或求商符放到S;被除数和除数变为绝对值

  - 用第一次上商判断溢出，赋值Y

  - 若无溢出，上商，AQ左移一位，根据上一次商值决定加减除数，n次后再上商（一共上商n+1次）

    ![image-20241019231714374](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019231714374-1729351035224-45.png)

    ![image-20241019231745225](D:\Internt of Thing\e_book\计算机组成原理\note\assets\image-20241019231745225-1729351067290-47.png)

- 上述为小数除法，对于整数除法，0<|除数|<=|被除数|。上述讨论的小数除法完全适用于整数除法，只是整数除法的被除数位数可以是除数的两倍， 且要求被除数的高 位要比除数 (n 位）小，否则即为溢出。





















































# 35B.说明浮点乘/除法运算的基本步骤。





1. 试比较基址寻址和变址寻址，并举例说明其适用的场合。
2. 任意写出五种寻址方式，令EA为有效地址，A为形式地址，写出这五种寻址方式计算有效地址的表达式。
3. 指令中有哪些字段？各有何作用？如何确定各字段的位数？
4. RISC和CISC指令系统各自的特点。
5. 请简述MIPS指令系统的R型、I型和J型指令格式，并举出指令实例。
6. 在MIPS指令子集实现的时候，如何从单周期数据通路构造流水线？
7. 流水线中有哪三种冒险？请简述，并至少举出一种解决冒险的方法。
8. 请简述Flynn分类法将计算机系统结构分成哪四类。
9. 请简述程序局部性原理。
10. 请简述Amdahl定律。
11. 影响CPU时间的因素包括什么？（提示：从CPU公式入手，考虑3个参数的影响因素）
12. 请简要说明提高计算机系统并行性的3种技术途径，并分别从单机和多机系统的角度举例。
13. 请说明什么是静态调度？什么是动态调度？动态调度的优点是什么？
14. 请简述Tomasulo算法的基本思想，并分析其局限性。
15. 请说明什么是动态分支预测？有何优点？
16. 请简述分支历史表BHT的基本思想。
17. 请简述分支目标缓冲器BTB的基本思想。
18. 请简述基于硬件的前瞻算法基本思想。
19. 请在PVP、SMP、MPP、DSM和COW中任选一种，简要描述其特点。
20. 什么是多处理机Cache一致性问题？
21. 请简述监听式协议的原理。
22. 请简述目录式协议的原理。（自学）
23. 请比较说明写作废协议和写更新协议性能上的差别。（自学）
24. 请解释，在目录式协议中，什么是本地节点、宿主节点、远程节点和共享集合？（自学）
25. 请简述目录式协议中，目录的三种结构。（自学）

